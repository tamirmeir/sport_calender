const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { FOOTBALL_API_KEY, API_BASE_URL, IS_DEMO_MODE, getSeasonYear } = require('../utils/config');
const cupWinners = require('../data/cup_winners');

// Path to the Active Leagues Cache (Generated by sync script)
const ACTIVE_LEAGUES_FILE = path.resolve(__dirname, '../data/active_leagues.json');

// Simple In-Memory Cache
const apiCache = {};
const CACHE_TTL = {
    fixtures: 6 * 60 * 60 * 1000,  // 6 Hours: Schedules don't change often
    static: 24 * 60 * 60 * 1000    // 24 Hours for countries/leagues
};

function getCache(key) {
    const entry = apiCache[key];
    if (!entry) return null;
    if (Date.now() > entry.expiry) {
        delete apiCache[key];
        return null;
    }
    return entry.data;
}

function setCache(key, data, type = 'fixtures') {
    apiCache[key] = {
        data,
        expiry: Date.now() + CACHE_TTL[type]
    };
}

class FootballApi {
    constructor() {
        this.headers = {
            'x-apisports-key': FOOTBALL_API_KEY,
            'x-apisports-host': 'v3.football.api-sports.io'
        };
    }

    async getFixturesByTeam(teamId, next = 10, leagueId = null) {
        if (IS_DEMO_MODE) return this.getMockFixtures();
        
        // Cache key includes league filtering if present
        const cacheKey = `fixtures_${teamId}_${next}${leagueId ? `_${leagueId}` : ''}`;
        const cached = getCache(cacheKey);
        if (cached) {
            console.log('Serving from Cache:', cacheKey);
            return cached;
        }

        try {
            let params;
            
            if (leagueId) {
                // API-Sports doesn't support team+league+next together
                // Use season-based query and filter for future games
                
                // Calendar-year leagues (Jan-Dec seasons) vs Academic-year leagues (Jul-Jun)
                // Most domestic European leagues use academic year
                // International/Continental tournaments + Americas/Asia use calendar year
                const CALENDAR_YEAR_LEAGUES = [
                    // Global
                    1,    // World Cup
                    10,   // Friendlies
                    15,   // FIFA Club World Cup
                    8,    // Women's World Cup
                    
                    // Continental - Europe (summer tournaments)
                    4,    // Euro Championship
                    5,    // UEFA Nations League
                    32,   // World Cup - Qualification Europe
                    
                    // Continental - South America (calendar year)
                    9,    // Copa America
                    13,   // CONMEBOL Libertadores
                    11,   // CONMEBOL Sudamericana
                    541,  // CONMEBOL Recopa
                    34,   // World Cup - Qualification South America
                    
                    // Continental - Asia (calendar year)
                    7,    // Asian Cup
                    17,   // AFC Champions League
                    18,   // AFC Cup
                    30,   // World Cup - Qualification Asia
                    1140, // AFC Women's Champions League
                    
                    // Continental - Africa (calendar year)
                    6,    // Africa Cup of Nations
                    12,   // CAF Champions League
                    20,   // CAF Confederation Cup
                    533,  // CAF Super Cup
                    29,   // World Cup - Qualification Africa
                    1164, // CAF Women's Champions League
                    
                    // Continental - North/Central America (calendar year)
                    16,   // CONCACAF Champions League
                    767,  // CONCACAF League
                    22,   // CONCACAF Gold Cup
                    536,  // CONCACAF Nations League
                    31,   // World Cup - Qualification CONCACAF
                    1136, // CONCACAF W Champions Cup
                ];
                const isCalendarLeague = CALENDAR_YEAR_LEAGUES.includes(parseInt(leagueId));
                const season = getSeasonYear(isCalendarLeague ? 'calendar' : 'academic');
                
                params = { team: teamId, league: leagueId, season };
                console.log(`[Fixtures] Fetching team ${teamId} in league ${leagueId} for season ${season} (${isCalendarLeague ? 'calendar' : 'academic'})`);
            } else {
                // Standard next N fixtures across all competitions
                params = { team: teamId, next };
            }

            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: params,
                headers: this.headers
            });
            
            let data = response.data.response;
            
            // If league filter was used, filter for future/upcoming games only
            if (leagueId && data.length > 0) {
                const now = new Date();
                data = data
                    .filter(f => new Date(f.fixture.date) >= now || f.fixture.status.short === 'NS')
                    .slice(0, next); // Limit to requested count
                console.log(`[Fixtures] Filtered to ${data.length} upcoming fixtures`);
            }
            
            setCache(cacheKey, data, 'fixtures');
            return data;
        } catch (error) {
            console.error('API Error:', error.message);
            return this.getMockFixtures();
        }
    }

    async getCountries() {
        if (IS_DEMO_MODE) return [{"name": "Israel", "code": "IL", "flag": "https://media.api-sports.io/flags/il.svg"}, {"name": "England", "code": "GB", "flag": "https://media.api-sports.io/flags/gb.svg"}];
        
        const cacheKey = 'countries_list';
        const cached = getCache(cacheKey);
        if (cached) return cached;

        try {
            const response = await axios.get(`${API_BASE_URL}/countries`, {
                headers: this.headers
            });
            const data = response.data.response;
            setCache(cacheKey, data, 'static');
            return data;
        } catch (error) {
            console.error('API Error (Countries):', error.message);
            return [];
        }
    }

    async getLeagues(country) {
        if (IS_DEMO_MODE) return [{"league":{"id":1,"name":"Ligat HaAl","type":"League","logo":"https://media.api-sports.io/football/leagues/1.png"},"country":{"name":"Israel","code":"IL","flag":"https://media.api-sports.io/flags/il.svg"},"seasons":[{"year":2023,"start":"2023-08-26","end":"2024-05-25","current":true}]}];
        
        // --- 1. Try Local Verified Cache First ---
        try {
            if (fs.existsSync(ACTIVE_LEAGUES_FILE)) {
                const raw = fs.readFileSync(ACTIVE_LEAGUES_FILE, 'utf-8');
                const allActive = JSON.parse(raw);
                
                // Filter for requested country & ensure active or vacation status
                // Also ignore "Archived" implicitly by checking against [active, vacation]
                const fromCache = allActive.filter(l => 
                    l.country.name === country && 
                    (l.verify_status === 'active' || l.verify_status === 'vacation')
                );

                if (fromCache.length > 0) {
                    // Transformation: Minimalist & Clean
                    const lightweight = fromCache.map(l => ({
                        id: l.league.id,
                        name: l.league.name,
                        type: l.league.type, // Kept for frontend routing
                        logo: l.league.logo,
                        status: l.verify_status,
                        ui_label: l.verify_status === 'active' ? "âš½ Active" : "ðŸ–ï¸ Vacation"
                    }));

                    // Logic: Sort by Status (Active First) -> Pinned ID 383 -> Name
                    lightweight.sort((a, b) => {
                        // 1. Status Priority: Active before Vacation
                        if (a.status !== b.status) {
                            return a.status === 'active' ? -1 : 1;
                        }
                        
                        // 2. Pin Specific ID (383 = Ligat Ha'al) to top of Active list
                        if (a.id === 383) return -1;
                        if (b.id === 383) return 1;

                        // 3. Alphabetical
                        return a.name.localeCompare(b.name);
                    });

                    console.log(`[API] Served ${lightweight.length} optimized leagues from cache (${country}).`);
                    return lightweight;
                }
            }
        } catch (e) {
            console.warn('[API] Failed to read active leagues cache, falling back to live API.', e.message);
        }
        
        // --- 2. Fallback to Standard API ---
        const cacheKey = `leagues_${country}`;
        const cached = getCache(cacheKey);
        if (cached) return cached;

        try {
            const response = await axios.get(`${API_BASE_URL}/leagues`, {
                params: { country: country, current: 'true' }, // Force current only for fallback
                headers: this.headers
            });
            console.log(`Fetched leagues for ${country}: ${response.data.response.length}`);
            
            const rawData = response.data.response;
            
            // Map to Lightweight format for consistency
            const lightweight = rawData.map(item => ({
                id: item.league.id,
                name: item.league.name,
                type: item.league.type,
                logo: item.league.logo,
                status: 'active', // Assume active for live fallback
                ui_label: "âš½ Active"
            }));
            
            setCache(cacheKey, lightweight, 'static');
            return lightweight;
        } catch (error) {
            console.error('API Error (Leagues):', error.message);
            return [];
        }
    }

    async getTeams(league, season) {
        if (IS_DEMO_MODE) return [{"team":{"id":1462,"name":"Maccabi Haifa","code":"MAC","country":"Israel","founded":1913,"national":false,"logo":"https://media.api-sports.io/football/teams/1462.png"},"venue":{"id":1111,"name":"Sammy Ofer Stadium","address":"Matam Park","city":"Haifa","capacity":30870,"surface":"grass","image":"https://media.api-sports.io/football/venues/1111.png"}}];
        
        const cacheKey = `teams_${league}_${season}`;
        const cached = getCache(cacheKey);
        if (cached) return cached;

        try {
            const response = await axios.get(`${API_BASE_URL}/teams`, {
                params: { league: league, season: season },
                headers: this.headers
            });
            const data = response.data.response;
            setCache(cacheKey, data, 'static');
            return data;
        } catch (error) {
            console.error('API Error (Teams):', error.message);
            return [];
        }
    }

    // --- Get League/Tournament Details (including frequency) ---
    async getLeagueDetails(leagueId) {
        const cacheKey = `league_details_${leagueId}`;
        const cached = getCache(cacheKey, 'static');
        if (cached) return cached;

        try {
            const response = await axios.get(`${API_BASE_URL}/leagues`, {
                params: { id: leagueId },
                headers: this.headers
            });

            const data = response.data.response?.[0];
            if (!data) return null;

            const league = data.league;
            const country = data.country;
            const seasons = data.seasons || [];

            // Calculate frequency from seasons
            let frequency = 1; // Default: yearly
            let frequencyLabel = 'Annual';
            
            if (seasons.length >= 2) {
                const recentSeasons = seasons.slice(-6);
                const gaps = [];
                for (let i = 1; i < recentSeasons.length; i++) {
                    gaps.push(recentSeasons[i].year - recentSeasons[i - 1].year);
                }
                if (gaps.length > 0) {
                    frequency = Math.round(gaps.reduce((a, b) => a + b, 0) / gaps.length);
                }
                
                // English labels
                if (frequency === 4) frequencyLabel = 'Every 4 years';
                else if (frequency === 2) frequencyLabel = 'Every 2 years';
                else if (frequency === 1) frequencyLabel = 'Annual';
                else frequencyLabel = `Every ${frequency} years`;
            }

            // Get current and next season
            const currentSeason = seasons.find(s => s.current) || seasons[seasons.length - 1];
            const allSeasonYears = seasons.map(s => s.year);

            const result = {
                id: league.id,
                name: league.name,
                type: league.type,           // 'League' or 'Cup'
                logo: league.logo,
                country: country.name,
                countryCode: country.code,
                countryFlag: country.flag,
                frequency,                   // Number (1, 2, 4, etc.)
                frequencyLabel,              // Hebrew string
                currentSeason: currentSeason?.year,
                seasonStart: currentSeason?.start,
                seasonEnd: currentSeason?.end,
                allSeasons: allSeasonYears,
                isTournament: league.type === 'Cup' && frequency > 1, // World Cup, Euro, etc.
                isAnnualCup: league.type === 'Cup' && frequency === 1, // FA Cup, Copa del Rey
                isLeague: league.type === 'League'
            };

            setCache(cacheKey, result, 'static');
            console.log(`[API] League ${leagueId}: ${result.name}, Type: ${result.type}, Frequency: ${result.frequencyLabel}`);
            return result;
        } catch (error) {
            console.error(`[API] Error fetching league details:`, error.message);
            return null;
        }
    }

    // --- Get League Status with Winner (for league cards display) ---
    // Returns league info + current status + winner if finished
    async getLeagueStatus(leagueId, season = null) {
        try {
            // Get league details first
            const details = await this.getLeagueDetails(leagueId);
            if (!details) return null;

            const targetSeason = season || details.currentSeason;
            
            // Get tournament info
            const tournamentInfo = await this.getTournamentInfo(leagueId, targetSeason);
            
            const result = {
                ...details,
                season: targetSeason,
                status: tournamentInfo?.currentStage || 'unknown',
                statusLabel: tournamentInfo?.currentStageLabel || 'Unknown',
                currentRound: tournamentInfo?.currentRound,
                currentRoundLabel: tournamentInfo?.currentRoundLabel,
                isFinished: tournamentInfo?.isFinished || false,
                isActive: tournamentInfo?.isGroupStage || tournamentInfo?.isKnockout || false,
                winner: null
            };

            // If finished, get the winner
            if (result.isFinished && (details.isAnnualCup || details.isTournament)) {
                const winner = await this.getCupWinner(leagueId, targetSeason);
                if (winner) {
                    result.winner = winner;
                    result.statusLabel = `ðŸ† ${winner.name}`;
                }
            }

            // For leagues (not cups), get the champion from standings
            if (result.isFinished && details.isLeague) {
                const standings = await this.getStandings(leagueId, targetSeason);
                if (standings?.[0]?.league?.standings?.[0]?.[0]) {
                    const champion = standings[0].league.standings[0][0].team;
                    result.winner = { 
                        id: champion.id, 
                        name: champion.name, 
                        logo: champion.logo 
                    };
                    result.statusLabel = `ðŸ‘‘ ${champion.name}`;
                }
            }

            console.log(`[API] League ${leagueId} status: ${result.statusLabel}`);
            return result;
        } catch (error) {
            console.error(`[API] Error getting league status:`, error.message);
            return null;
        }
    }

    async getStandings(league, season) {
        if (IS_DEMO_MODE) return [];
        
        const cacheKey = `standings_${league}_${season}`;
        const cached = getCache(cacheKey, 'fixtures'); // Use 6h cache (standings update with games)
        if (cached) return cached;

        try {
            console.log(`[API] Fetching Standings: League ${league}, Season ${season}`);
            const response = await axios.get(`${API_BASE_URL}/standings`, {
                params: { league: league, season: season },
                headers: this.headers
            });
            
            const data = response.data.response;
            // Standings can be empty if season not started
            setCache(cacheKey, data, 'fixtures');
            return data;
        } catch (error) {
            console.error('API Error (Standings):', error.message);
            return []; // Return empty, caller handles fallback
        }
    }

    async getNationalTeam(country) {
        if (IS_DEMO_MODE) return [{"team": {id: 767, name: "Israel", national: true, logo: "https://media.api-sports.io/football/teams/767.png"}}];
        try {
            console.log(`Fetching National Team for: ${country}`);
            
            // Fix: API-Sports search fails when combining country + search for same string
            // Strategy: Search globally for the country name, then filter by country + national flag
            const response = await axios.get(`${API_BASE_URL}/teams`, {
                params: { search: country }, 
                headers: this.headers
            });
            
            const results = response.data.response;
            
            // Filter strictly:
            // 1. Must be a National Team
            // 2. Must belong to the requested Country
            // 3. Exclude "U21", "U19", "Women" to get the main Senior Team (optional, but usually desired as default)
            const nationalTeams = results.filter(t => 
                t.team.national === true && 
                t.team.country === country &&
                !t.team.name.includes('U21') &&
                !t.team.name.includes('U19') &&
                !t.team.name.includes('U17') &&
                !t.team.name.includes('Women')
            );

            if (nationalTeams.length > 0) {
                 console.log(`Found ${nationalTeams.length} national teams. Returning top match.`);
                 return nationalTeams;
            }

            console.log(`Structure check: Found ${results.length} total via search, but 0 matches after filter.`);
            return [];

        } catch (error) {
            console.error('API Error (National Team):', error.message);
            return [];
        }
    }

    async getFixturesByLeague(league, season, next = null, last = null, status = null) {
        // Cache key
        const cacheKey = `fixtures_lg_${league}_${season}_n${next}_l${last}_s${status}`;
        const cached = getCache(cacheKey);
        if (cached) return cached;

        try {
            const params = { league: league, season: season };
            
            // Priority: Status (All matching) > Last > Next
            if (status) {
                params.status = status;
            } else if (last) {
                params.last = last;
            } else {
                params.next = next || 10; // Default if nothing provided
            }

            console.log(`[API] Fetching League Fixtures:`, params);
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: params,
                headers: this.headers
            });
            const data = response.data.response;
            setCache(cacheKey, data, 'fixtures');
            return data;
        } catch (error) {
            console.error('API Error (League Fixtures):', error.message);
            return [];
        }
    }

    /**
     * Universal Active Teams Funnel (Refactored)
     * Finds participating teams for a league/cup via:
     * 1. Upcoming Fixtures (Primary)
     * 2. Standings Table (Fallback for breaks/international windows)
     * 3. Recent Fixtures (Safety Net)
     * 4. Full Team List (Ultimate Fallback)
     * @param {number} leagueId 
     * @param {number} season 
     * @returns {Promise<Array>} List of clean ActiveTeam objects
     */
    async getActiveTournamentTeams(leagueId, season) {
        const cacheKey = `active_teams_${leagueId}_${season}`;
        
        const cached = getCache(cacheKey, 'fixtures');
        if (cached) {
            console.log(`[Funnel] Serving Cached Active Teams for ${leagueId}`);
            return cached;
        }

        console.log(`[Funnel] Starting Active Teams Search for League ${leagueId}/${season}`);
        const uniqueTeams = new Map();

        // Helper: Add team to unique map
        const addTeam = (t) => {
            if (t && t.id && !uniqueTeams.has(t.id)) {
                uniqueTeams.set(t.id, { id: t.id, name: t.name, logo: t.logo });
            }
        };

        // Helper: Enrich basic team IDs with full details (Venue, City, Code)
        const enrichTeams = async () => {
            if (uniqueTeams.size === 0) return [];
            
            try {
                const activeIds = new Set(uniqueTeams.keys());
                const allTeamsRich = await this.getTeams(leagueId, season);
                
                const enriched = allTeamsRich
                    .filter(item => item.team && activeIds.has(item.team.id))
                    .map(item => ({
                        id: item.team.id,
                        name: item.team.name,
                        logo: item.team.logo,
                        code: item.team.code,
                        founded: item.team.founded,
                        national: item.team.national,
                        venue: item.venue || {}
                    }));
                
                return enriched.length > 0 ? enriched : Array.from(uniqueTeams.values());
            } catch (err) {
                console.warn("[Funnel] Enrichment Error:", err.message);
                return Array.from(uniqueTeams.values());
            }
        };

        // --- Phase 1: Upcoming Fixtures (Primary Check) ---
        try {
            console.log("[Funnel] Phase 1: Checking Future Fixtures (status=NS)...");
            const futureFixtures = await this.getFixturesByLeague(leagueId, season, null, null, 'NS');
            
            if (futureFixtures && futureFixtures.length > 0) {
                futureFixtures.forEach(f => {
                    if (f.teams) {
                        addTeam(f.teams.home);
                        addTeam(f.teams.away);
                    }
                });
                console.log(`[Funnel] Phase 1 Success: Found ${uniqueTeams.size} teams from future games.`);
                
                const result = await enrichTeams();
                setCache(cacheKey, result, 'fixtures');
                return result;
            }
        } catch (err) {
            console.warn("[Funnel] Phase 1 Error:", err.message);
        }

        // --- Phase 2: Standings Fallback (For Leagues in Break / International Windows) ---
        try {
            console.log("[Funnel] Phase 1 Empty. Phase 2: Checking Standings...");
            const standingsData = await this.getStandings(leagueId, season);
            
            let flatList = [];
            if (standingsData && standingsData.length > 0 && standingsData[0].league && standingsData[0].league.standings) {
                // Standings can be: [[Group A], [Group B]] or just [Team1, Team2...]
                flatList = standingsData[0].league.standings.flat();
            }

            if (flatList.length > 0) {
                // Include all teams from standings (don't filter eliminated during breaks)
                flatList.forEach(s => addTeam(s.team));
                console.log(`[Funnel] Phase 2 Success: Found ${uniqueTeams.size} teams from Standings.`);
                
                const result = await enrichTeams();
                setCache(cacheKey, result, 'fixtures');
                return result;
            }
        } catch (err) {
            console.warn("[Funnel] Phase 2 Error:", err.message);
        }

        // --- Phase 3: Recent History (Safety Net) ---
        try {
            console.log("[Funnel] Phase 2 Empty. Phase 3: Checking Recent Fixtures (Last 20)...");
            const recentFixtures = await this.getFixturesByLeague(leagueId, season, null, 20, null);
            
            if (recentFixtures && recentFixtures.length > 0) {
                recentFixtures.forEach(f => {
                    if (f.teams) {
                        addTeam(f.teams.home);
                        addTeam(f.teams.away);
                    }
                });
                console.log(`[Funnel] Phase 3 Success: Found ${uniqueTeams.size} teams from recent history.`);
                
                const result = await enrichTeams();
                setCache(cacheKey, result, 'fixtures');
                return result;
            }
        } catch (err) {
            console.warn("[Funnel] Phase 3 Error:", err.message);
        }

        // --- Phase 4: Full Team List (Ultimate Fallback) ---
        try {
            console.log("[Funnel] Phase 3 Empty. Phase 4: Fetching Full Team List...");
            const allTeams = await this.getTeams(leagueId, season);
            
            if (allTeams && allTeams.length > 0) {
                const result = allTeams.map(item => ({
                    id: item.team.id,
                    name: item.team.name,
                    logo: item.team.logo,
                    code: item.team.code,
                    founded: item.team.founded,
                    national: item.team.national,
                    venue: item.venue || {}
                }));
                console.log(`[Funnel] Phase 4 Success: Found ${result.length} teams from Full List.`);
                setCache(cacheKey, result, 'static');
                return result;
            }
        } catch (err) {
            console.warn("[Funnel] Phase 4 Error:", err.message);
        }

        console.log("[Funnel] All Phases Failed. Returning 0 teams.");
        return [];
    }


    async getFixtureById(id) {
        // Implementation for single fixture
         try {
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { id: id },
                headers: this.headers
            });
            return response.data.response[0]; // Return single object
        } catch (error) {
            return null;
        }
    }
    
    async getFixturesByDate(date) {
         try {
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { date: date },
                headers: this.headers
            });
            return response.data.response;
        } catch (error) {
            return [];
        }
    }
    
    async getPastFixtures(teamId, last = 10) {
         try {
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { team: teamId, last: last, status: 'FT-AET-PEN' },
                headers: this.headers
            });
            return response.data.response;
        } catch (error) {
            return [];
        }
    }

    /**
     * Get the current season year for a specific league
     * Some leagues like UEFA Nations League, World Cup Qualifiers have non-standard year cycles
     */
    async getCurrentSeasonForLeague(leagueId) {
        const cacheKey = `current_season_${leagueId}`;
        const cached = getCache(cacheKey, 'static');
        if (cached) return cached;

        try {
            const response = await axios.get(`${API_BASE_URL}/leagues`, {
                params: { id: leagueId },
                headers: this.headers
            });
            
            const leagues = response.data.response;
            if (leagues && leagues.length > 0) {
                const seasons = leagues[0].seasons || [];
                const current = seasons.find(s => s.current);
                if (current) {
                    console.log(`[API] League ${leagueId} current season: ${current.year}`);
                    setCache(cacheKey, current.year, 'static');
                    return current.year;
                }
                // Fallback to latest season
                if (seasons.length > 0) {
                    const latest = seasons[seasons.length - 1].year;
                    setCache(cacheKey, latest, 'static');
                    return latest;
                }
            }
        } catch (error) {
            console.error(`[API] Error fetching current season for league ${leagueId}:`, error.message);
        }
        return null;
    }

    getMockFixtures() {
        return [{ fixture: { id: 1, date: new Date().toISOString() }, teams: { home: { name: 'Demo FC' }, away: { name: 'Mock City' } } }];
    }

    /**
     * Get all leagues/competitions a team is currently participating in
     * Returns categorized data: { leagues: [], cups: [], continental: [] }
     * Works globally for all confederations (UEFA, CONMEBOL, AFC, CAF, CONCACAF, OFC)
     * Only includes competitions where the team has upcoming fixtures (hides eliminated teams)
     */
    async getLeaguesByTeam(teamId, isNational = false) {
        if (IS_DEMO_MODE) return { leagues: [], cups: [], continental: [], raw: [] };

        const cacheKey = `team_leagues_active_${teamId}`;
        const cached = getCache(cacheKey);
        if (cached) {
            console.log('Serving team leagues from Cache:', cacheKey);
            return cached;
        }

        try {
            // Step 1: Get upcoming fixtures for the team
            // Using next=50 to catch competitions with sparse fixtures (like Champions League)
            const fixturesResponse = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { team: teamId, next: 50 },
                headers: this.headers
            });
            const upcomingFixtures = fixturesResponse.data.response || [];
            
            // Build a Set of league IDs that have upcoming fixtures
            const activeLeagueIds = new Set();
            for (const fixture of upcomingFixtures) {
                if (fixture.league?.id) {
                    activeLeagueIds.add(fixture.league.id);
                }
            }
            console.log(`[API] Team ${teamId} has upcoming fixtures in ${upcomingFixtures.length} games, leagues:`, [...activeLeagueIds]);

            // Step 2: Get all registered leagues for context (names, logos, types)
            const leaguesResponse = await axios.get(`${API_BASE_URL}/leagues`, {
                params: { team: teamId, current: 'true' },
                headers: this.headers
            });
            const rawLeagues = leaguesResponse.data.response || [];
            
            // Categorize leagues - only include those with upcoming fixtures
            const result = {
                leagues: [],
                cups: [],
                continental: [],
                national: {
                    major: [],
                    qualifiers: [],
                    friendlies: [],
                    nationsLeague: []
                },
                raw: rawLeagues
            };

            // Helper: Check if competition name indicates continental/international
            const isContinentalByName = (name) => {
                const continentalKeywords = [
                    // UEFA
                    'Champions League', 'Europa League', 'Conference League', 'UEFA', 'Super Cup',
                    // CONMEBOL
                    'Libertadores', 'Sudamericana', 'Recopa', 'CONMEBOL',
                    // AFC
                    'AFC Champions', 'AFC Cup', 'A-League',
                    // CAF
                    'CAF Champions', 'CAF Confederation', 'CAF Super',
                    // CONCACAF
                    'CONCACAF Champions', 'Leagues Cup', 'Campeones Cup',
                    // General
                    'Club World', 'Intercontinental'
                ];
                return continentalKeywords.some(kw => name.includes(kw));
            };

            // Helper: Check if it's a major international tournament for national teams
            const isMajorTournament = (name, id) => {
                const majorKeywords = ['World Cup', 'Euro 20', 'Copa America', 'AFCON', 'Africa Cup', 
                    'Asian Cup', 'Gold Cup', 'Nations Cup', 'Confederations'];
                const majorIds = [1, 4, 9, 6, 33, 37, 8, 29]; // Known major tournament IDs
                return majorIds.includes(id) || majorKeywords.some(kw => name.includes(kw));
            };

            // Helper: Check if it's a qualifier
            const isQualifier = (name) => {
                return name.toLowerCase().includes('qualif') || name.toLowerCase().includes('qualification');
            };

            // Helper: Check if it's friendlies
            const isFriendly = (name, id) => {
                return id === 10 || name.toLowerCase().includes('friendl');
            };

            // Helper: Check if it's Nations League type competition
            const isNationsLeague = (name) => {
                return name.includes('Nations League') || name.includes('Nations Cup');
            };

            for (const item of rawLeagues) {
                const league = item.league;
                
                // Skip competitions without upcoming fixtures (team eliminated)
                if (!activeLeagueIds.has(league.id)) {
                    console.log(`[API] Skipping ${league.name} (ID: ${league.id}) - no upcoming fixtures`);
                    continue;
                }
                
                const leagueInfo = {
                    id: league.id,
                    name: league.name,
                    type: league.type,
                    logo: league.logo,
                    country: item.country?.name || 'International'
                };

                if (isNational) {
                    // National team categorization
                    if (isMajorTournament(league.name, league.id)) {
                        result.national.major.push(leagueInfo);
                    } else if (isQualifier(league.name)) {
                        result.national.qualifiers.push(leagueInfo);
                    } else if (isFriendly(league.name, league.id)) {
                        result.national.friendlies.push(leagueInfo);
                    } else if (isNationsLeague(league.name)) {
                        result.national.nationsLeague.push(leagueInfo);
                    } else if (league.type === 'Cup') {
                        // Other national team tournaments go to major
                        result.national.major.push(leagueInfo);
                    }
                } else {
                    // Club team categorization - use name detection for global compatibility
                    if (isContinentalByName(league.name)) {
                        result.continental.push(leagueInfo);
                    } else if (league.type === 'League') {
                        result.leagues.push(leagueInfo);
                    } else if (league.type === 'Cup') {
                        result.cups.push(leagueInfo);
                    }
                }
            }

            setCache(cacheKey, result, 'fixtures'); // Cache for 6 hours (fixtures change more often)
            console.log(`[API] Team ${teamId} ACTIVE competitions:`, {
                leagues: result.leagues.length,
                cups: result.cups.length,
                continental: result.continental.length
            });
            return result;
        } catch (error) {
            console.error(`[API] Error fetching leagues for team ${teamId}:`, error.message);
            return { leagues: [], cups: [], continental: [], national: { major: [], qualifiers: [], friendlies: [], nationsLeague: [] }, raw: [] };
        }
    }

    // --- NEW: Get next fixture for a league (for countdown display) ---
    async getNextLeagueFixture(leagueId) {
        const cacheKey = `league_next_${leagueId}`;
        const cached = getCache(cacheKey, 'fixtures');
        if (cached) return cached;

        try {
            const season = getSeasonYear('academic');
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { league: leagueId, season: season, next: 1 },
                headers: this.headers
            });

            const fixtures = response.data.response || [];
            if (fixtures.length === 0) {
                const result = { hasNext: false, fixture: null };
                setCache(cacheKey, result, 'fixtures');
                return result;
            }

            const f = fixtures[0];
            const result = {
                hasNext: true,
                fixture: {
                    id: f.fixture.id,
                    date: f.fixture.date,
                    homeTeam: f.teams.home.name,
                    awayTeam: f.teams.away.name,
                    homeLogo: f.teams.home.logo,
                    awayLogo: f.teams.away.logo,
                    venue: f.fixture.venue?.name || null,
                    round: f.league.round
                }
            };

            setCache(cacheKey, result, 'fixtures');
            console.log(`[API] Next fixture for league ${leagueId}: ${result.fixture.homeTeam} vs ${result.fixture.awayTeam}`);
            return result;
        } catch (error) {
            console.error(`[API] Error fetching next fixture for league ${leagueId}:`, error.message);
            return { hasNext: false, fixture: null };
        }
    }

    // --- Get Cup Competition Winner (from Final fixture) ---
    // For cup competitions like Champions League, Europa League, domestic cups
    // The API doesn't have rank=1 for cup winners, so we fetch the Final fixture
    async getCupWinner(leagueId, season) {
        const cacheKey = `cup_winner_${leagueId}_${season}`;
        const cached = getCache(cacheKey, 'static');
        if (cached) return cached;

        try {
            console.log(`[API] Fetching Cup Final for league ${leagueId}, season ${season}`);
            
            // Fetch the Final round fixture
            const response = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { 
                    league: leagueId, 
                    season: season, 
                    round: 'Final'
                },
                headers: this.headers
            });

            const fixtures = response.data.response || [];
            if (fixtures.length === 0) {
                console.log(`[API] No Final fixture found for league ${leagueId} season ${season}`);
                setCache(cacheKey, null, 'static');
                return null;
            }

            // Find the fixture with status FT (finished)
            const finalGame = fixtures.find(f => 
                f.fixture.status.short === 'FT' || 
                f.fixture.status.short === 'AET' || 
                f.fixture.status.short === 'PEN'
            );

            if (!finalGame) {
                console.log(`[API] Final not yet played for league ${leagueId} season ${season}`);
                setCache(cacheKey, null, 'static');
                return null;
            }

            // Determine the winner
            const homeTeam = finalGame.teams.home;
            const awayTeam = finalGame.teams.away;
            let winner = null;

            if (homeTeam.winner === true) {
                winner = { id: homeTeam.id, name: homeTeam.name, logo: homeTeam.logo };
            } else if (awayTeam.winner === true) {
                winner = { id: awayTeam.id, name: awayTeam.name, logo: awayTeam.logo };
            }

            if (winner) {
                console.log(`[API] Cup winner (${leagueId}/${season}): ${winner.name} (ID: ${winner.id})`);
            }

            setCache(cacheKey, winner, 'static');
            return winner;
        } catch (error) {
            console.error(`[API] Error fetching cup winner:`, error.message);
            return null;
        }
    }

    // --- Get Tournament Stage Info (for World Cup, Euro, Copa America, etc.) ---
    // Returns current stage, groups/standings, and teams still in competition
    async getTournamentInfo(leagueId, season) {
        const cacheKey = `tournament_info_${leagueId}_${season}`;
        const cached = getCache(cacheKey, 'fixtures');
        if (cached) return cached;

        try {
            console.log(`[API] Getting tournament info for league ${leagueId}, season ${season}`);
            
            // Fetch in parallel: rounds, standings, next fixture, last fixture
            const [roundsRes, standingsRes, nextRes, lastRes] = await Promise.all([
                axios.get(`${API_BASE_URL}/fixtures/rounds`, {
                    params: { league: leagueId, season: season },
                    headers: this.headers
                }),
                axios.get(`${API_BASE_URL}/standings`, {
                    params: { league: leagueId, season: season },
                    headers: this.headers
                }),
                axios.get(`${API_BASE_URL}/fixtures`, {
                    params: { league: leagueId, season: season, next: 1 },
                    headers: this.headers
                }),
                axios.get(`${API_BASE_URL}/fixtures`, {
                    params: { league: leagueId, season: season, last: 1 },
                    headers: this.headers
                })
            ]);

            const rounds = roundsRes.data.response || [];
            const standingsData = standingsRes.data.response?.[0]?.league?.standings || [];
            const nextFixture = nextRes.data.response?.[0] || null;
            const lastFixture = lastRes.data.response?.[0] || null;

            // Determine current stage
            let currentStage = 'not_started';
            let currentRound = null;
            
            if (nextFixture) {
                currentRound = nextFixture.league.round;
                currentStage = this._classifyRound(currentRound);
            } else if (lastFixture) {
                currentRound = lastFixture.league.round;
                currentStage = 'finished';
            }

            // Build groups data (for group stage)
            const groups = standingsData.map(group => ({
                name: group[0]?.group || 'Unknown',
                teams: group.map(entry => ({
                    id: entry.team.id,
                    name: entry.team.name,
                    logo: entry.team.logo,
                    rank: entry.rank,
                    points: entry.points,
                    played: entry.all?.played || 0,
                    won: entry.all?.win || 0,
                    draw: entry.all?.draw || 0,
                    lost: entry.all?.lose || 0,
                    goalsFor: entry.all?.goals?.for || 0,
                    goalsAgainst: entry.all?.goals?.against || 0,
                    goalsDiff: entry.goalsDiff
                }))
            }));

            // For knockout stages, get teams still in competition
            let knockoutTeams = [];
            if (currentStage === 'knockout' || currentStage === 'finished') {
                knockoutTeams = await this._getKnockoutTeams(leagueId, season, currentRound);
            }

            // Stage display names
            const stageLabels = {
                'not_started': 'Not Started',
                'in_progress': 'In Progress',
                'group_stage': 'Group Stage',
                'knockout': 'Knockout Stage',
                'league_playoffs': 'Playoffs',
                'finished': 'Finished'
            };

            const result = {
                leagueId,
                season,
                rounds,
                currentStage,      // 'not_started', 'group_stage', 'knockout', 'finished'
                currentStageLabel: stageLabels[currentStage] || currentStage,  // Hebrew
                currentRound,      // e.g., 'Group Stage - 2', 'Quarter-finals'
                currentRoundLabel: this._getRoundDisplayName(currentRound),    // Hebrew
                groups,            // Group stage standings
                knockoutTeams,     // Teams still in knockout stage
                nextFixture: nextFixture ? {
                    id: nextFixture.fixture.id,
                    date: nextFixture.fixture.date,
                    round: nextFixture.league.round,
                    roundLabel: this._getRoundDisplayName(nextFixture.league.round),
                    home: nextFixture.teams.home,
                    away: nextFixture.teams.away
                } : null,
                isGroupStage: currentStage === 'group_stage',
                isKnockout: currentStage === 'knockout',
                isFinished: currentStage === 'finished'
            };

            setCache(cacheKey, result, 'fixtures');
            console.log(`[API] Tournament ${leagueId}: stage=${currentStage}, round=${currentRound}, groups=${groups.length}`);
            return result;
        } catch (error) {
            console.error(`[API] Error getting tournament info:`, error.message);
            return null;
        }
    }

    // Helper: Classify round type
    _classifyRound(round) {
        if (!round) return 'not_started';
        const r = round.toLowerCase();
        
        // Regular league season patterns (NOT group stage)
        if (r.includes('regular season') || r.match(/^regular season - \d+/) ||
            r.match(/^\d+$/) ||                               // Just a number like "21"
            r.match(/^round \d+$/) ||                        // "Round 21"
            r.match(/^matchday \d+$/)) {                     // "Matchday 21"
            return 'in_progress';
        }
        
        // Group stage patterns (actual group stages in cups/tournaments)
        if (r.includes('group stage') || r.includes('league stage') || 
            r.match(/league [a-d] - \d/) ||                  // Nations League format: "League A - 1"
            r.match(/^group [a-z] - \d+/)) {                 // "Group A - 1"
            return 'group_stage';
        }
        
        // Knockout patterns
        if (r.includes('round of') || r.includes('quarter') || r.includes('semi') || 
            r.includes('final') || r.includes('knockout') || r.includes('play-off')) {
            return 'knockout';
        }
        
        // Qualification patterns (treated as group stage)
        if (r.includes('qualifying') || r.includes('qualification')) {
            return 'group_stage';
        }
        
        // League split playoffs (Israel, Scotland, Belgium, etc.)
        // Championship Round = upper playoff, Relegation Round = lower playoff
        if (r.includes('championship round') || r.includes('relegation round')) {
            return 'league_playoffs';
        }
        
        // 1st Phase / 2nd Phase (Scotland style)
        if (r.includes('1st phase') || r.includes('2nd phase')) {
            return 'in_progress';
        }
        
        return 'in_progress'; // Default - assume regular league play
    }

    // Helper: Get round display name
    _getRoundDisplayName(round) {
        if (!round) return '';
        const r = round.toLowerCase();
        
        // World Cup / Euro style
        if (r.includes('group stage - 1')) return 'Group Stage - Matchday 1';
        if (r.includes('group stage - 2')) return 'Group Stage - Matchday 2';
        if (r.includes('group stage - 3')) return 'Group Stage - Matchday 3';
        if (r.includes('round of 16')) return 'Round of 16';
        if (r.includes('round of 32')) return 'Round of 32';
        if (r.includes('quarter')) return 'Quarter-finals';
        if (r.includes('semi')) return 'Semi-finals';
        if (r.includes('3rd place')) return '3rd Place Match';
        if (r === 'final') return 'Final';
        
        // Nations League style
        if (r.match(/league ([a-d]) - (\d)/i)) {
            const match = r.match(/league ([a-d]) - (\d)/i);
            return `League ${match[1].toUpperCase()} - Matchday ${match[2]}`;
        }
        if (r.includes('play-off')) return 'Play-offs';
        
        // Champions League style
        if (r.includes('league stage')) return 'League Stage';
        if (r.includes('knockout round play')) return 'Knockout Round';
        
        // League playoffs (Israel, Scotland, Belgium)
        if (r.includes('championship round')) {
            const match = r.match(/championship round - (\d+)/i);
            return match ? `Championship Playoffs - Round ${match[1]}` : 'Championship Playoffs';
        }
        if (r.includes('relegation round')) {
            const match = r.match(/relegation round - (\d+)/i);
            return match ? `Relegation Playoffs - Round ${match[1]}` : 'Relegation Playoffs';
        }
        
        // Scotland 1st/2nd phase
        if (r.includes('1st phase')) {
            const match = r.match(/1st phase - (\d+)/i);
            return match ? `Phase 1 - Matchday ${match[1]}` : 'Phase 1';
        }
        if (r.includes('2nd phase')) {
            const match = r.match(/2nd phase - (\d+)/i);
            return match ? `Phase 2 - Matchday ${match[1]}` : 'Phase 2';
        }
        
        // Regular Season
        if (r.includes('regular season')) {
            const match = r.match(/regular season - (\d+)/i);
            return match ? `Matchday ${match[1]}` : 'Regular Season';
        }
        
        return round; // Return original if no match
    }

    // Helper: Get teams still in knockout stage
    async _getKnockoutTeams(leagueId, season, currentRound) {
        try {
            // Fetch fixtures for current knockout round
            const res = await axios.get(`${API_BASE_URL}/fixtures`, {
                params: { league: leagueId, season: season, round: currentRound },
                headers: this.headers
            });
            
            const teams = new Map();
            (res.data.response || []).forEach(f => {
                const home = f.teams.home;
                const away = f.teams.away;
                teams.set(home.id, { id: home.id, name: home.name, logo: home.logo });
                teams.set(away.id, { id: away.id, name: away.name, logo: away.logo });
            });
            
            return Array.from(teams.values());
        } catch (error) {
            console.error(`[API] Error fetching knockout teams:`, error.message);
            return [];
        }
    }

    // --- NEW: Get teams with standings for table position display ---
    async getTeamsWithStandings(leagueId, season, country = null) {
        console.log(`[API] getTeamsWithStandings called: league=${leagueId}, season=${season}, country=${country}`);
        const cacheKey = `teams_standings_${leagueId}_${season}_${country || 'unknown'}`;
        const cached = getCache(cacheKey, 'fixtures');
        if (cached) {
            console.log(`[API] Cache HIT for ${cacheKey}`);
            return cached;
        }
        console.log(`[API] Cache MISS for ${cacheKey}, fetching from API...`);

        try {
            // Fetch teams, current standings, and previous season standings (for defending champion)
            const prevSeason = parseInt(season) - 1;
            const [teamsData, standingsData, prevStandingsData] = await Promise.all([
                this.getTeams(leagueId, season),
                this.getStandings(leagueId, season),
                this.getStandings(leagueId, prevSeason).catch(() => []) // Don't fail if no prev season
            ]);
            
            console.log(`[API] Got ${teamsData?.length || 0} teams, ${standingsData?.length || 0} standings entries`);

            // Find defending league champion (rank 1 from previous season's Championship/final group)
            let defendingChampionId = null;
            if (prevStandingsData && prevStandingsData.length > 0 && prevStandingsData[0]?.league?.standings) {
                const prevGroups = prevStandingsData[0].league.standings;
                // Look for Championship round first, otherwise use first group
                const championshipGroup = prevGroups.find(g => 
                    g[0]?.group?.toLowerCase().includes('championship') || 
                    g[0]?.group?.toLowerCase().includes('title')
                ) || prevGroups[0];
                
                if (championshipGroup && championshipGroup[0]) {
                    defendingChampionId = championshipGroup[0].team.id;
                    console.log(`[API] Defending league champion: ${championshipGroup[0].team.name} (ID: ${defendingChampionId})`);
                }
            }

            // Find cup winner from previous season (using local data)
            let cupWinnerId = null;
            if (country) {
                cupWinnerId = cupWinners.getCupWinner(country, prevSeason);
                if (cupWinnerId) {
                    console.log(`[API] Cup winner (${country} ${prevSeason}): Team ID ${cupWinnerId}`);
                }
            }

            // Build standings lookup map
            const standingsMap = new Map();
            let standingsGroups = [];
            if (standingsData && standingsData.length > 0 && standingsData[0]?.league?.standings) {
                const allGroups = standingsData[0].league.standings;
                standingsGroups = allGroups.map(group => ({
                    name: group[0]?.group || 'Regular Season',
                    teams: group.map(e => e.team.id)
                }));
                
                const allStandings = allGroups.flat();
                allStandings.forEach(entry => {
                    standingsMap.set(entry.team.id, {
                        rank: entry.rank,
                        points: entry.points,
                        goalsDiff: entry.goalsDiff,
                        form: entry.form,
                        played: entry.all?.played || 0,
                        won: entry.all?.win || 0,
                        draw: entry.all?.draw || 0,
                        lost: entry.all?.lose || 0,
                        group: entry.group || null,
                        description: entry.description || null
                    });
                });
            }

            // Merge teams with standings data
            const mergedTeams = teamsData.map(item => {
                const team = item.team || {};
                const standing = standingsMap.get(team.id) || null;
                return {
                    ...item,
                    standing: standing,
                    isDefendingChampion: team.id === defendingChampionId,  // ðŸ‘‘ League champion
                    isCupWinner: team.id === cupWinnerId                   // ðŸ† Cup winner
                };
            });

            // Sort by rank (teams with standings first, then others)
            mergedTeams.sort((a, b) => {
                const rankA = a.standing?.rank ?? 999;
                const rankB = b.standing?.rank ?? 999;
                return rankA - rankB;
            });

            setCache(cacheKey, mergedTeams, 'fixtures');
            console.log(`[API] Merged ${mergedTeams.length} teams with standings for league ${leagueId}`);
            return mergedTeams;
        } catch (error) {
            console.error(`[API] Error fetching teams with standings:`, error.message);
            // Fallback to just teams without standings
            return await this.getTeams(leagueId, season);
        }
    }
}

module.exports = new FootballApi();
